#+TITLE: Trabalho de Grupo n¬∫ 1 Sistemas Operativos
#+LATEX_CLASS: report
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_CLASS_OPTIONS: [a4paper]
#+AUTHOR: Jos√© Galinha n¬∫ 13077, 
#+AUTHOR: Luis Adriando n¬∫ 15367
#+LANGUAGE: pt
#+LATEX_HEADER: \usepackage[AUTO]{babel}

* 
** Intrudu√ß√£o
O Objectivo deste trabalho √© a elabora√ß√£o de um conjusto de scripts utilizando as v√°rias liguagens de script disponiveis para o sistema operativo Linux e Windows com o objetivo de desenvolver uma ferramenta de cria√ß√£o de dicion√°rios para o programa Eug√©nio V3. O programa Eug√©nio V3 trata-se de uma ferramente de predi√ß√£o de palavras para o uso de pessoas que tenham dificuldades motoras que lhe dificultem escrever em teclado.

* Etapas de desenvolvimento
# Nesta parte do relat√≥rios iremos descrever os scripts para realizar as diversas tarefas pedidas no trabalho.
** Prepara√ß√£o
Nesta estapa iremos usars um cript para configurar a estrutura de pastas a ser utilizada, assim como a descompre√ß√£o do ficheiro do /switchboard/. Para este primeiro passo foi desenvolvido o script =main.sh=.

*** Ficheiro main.sh

Para facilitar uso dos v√°rios scripts, foi criado um script =main.sh= que serve como menu para as v√°rias op√ß√µes, assim como verifica√ß√£o dos sistemas de pastas necess√°rias para o funcionamento dos scripts, criando as mesmas caso ainda n√£o existam, assim como localiza tamb√©m o ficheiro do switchboard a usar para cria√ß√£o dos diversos dicion√°rios, solicitado a localixa√ß√£o do mesmo caso este n√£o exista.


O script =main.sh= disp√µe de tr√™s func√µes principais, a /=SwitchBoard()=/ que verificar a exist√™ncia do ficheiro /switchboard.zip/ na raiz do script, n√£o a localizando, questiona o utilizador da localiza√ß√£o da mesma. A fun√ß√£o /=CheckFolderStructure()=/ verifica a exist√™ncia da estrutura de pastas pretendida criando a mesma caso n√£o exista. Por fim a fun√ß√£o /=Carregar_Script()=/ √© a fun√ß√£o utilizada para chamar os v√°rios scripts utilizados na cria√ß√£o dos diversos ficheiros.


O ficheiro termina com um cliclo /while/ que funciona como menu do sistema com as v√°rias op√ß√µes do mesmo.

#+NAME: main.sh
#+BEGIN_SRC bash -n 
#!/usr/bin/env bash
# Autores: Jos√© Galinha, Luis Adriano
# Main script para utiliza√ß√£o no trabalho de grupo 1 da disciplina SO
# 
set -euo pipefail

# Vari√°vel que define o nome do ficheiro a localizar por defeitos
SWITCHBOARD_FILE="switchboard.zip"
# Vari√°vel que Define quais s√£o as pastas necess√°rias para o funcionamento do 
DIRS=("scripts" "corpus" "corpus_txt" "corpus_info" "words_dic" "sentences_dic")
FILE_LOCATED=false
DIR_STRUCT_OK=false
SCRIPT="scripts/criar_ficheiros.sh" # script usado para criar os v√°rios ficheiro de texto
CORPUS_TXT='corpus_txt/switchboard.txt'
LIMIT=250000 # Limite de linhas na cria√ß√£o dos ficheiros
feeling="sleep 0.5"

# Fun√ß√£o que procura o ficheiro do switchboard e se n√£o encontrar solicita a sua
# localiza√ß√£o
SwitchBoard(){
    echo "üîé Localizando o ficheiro $SWITCHBOARD_FILE"
    $feeling
    if [ -f $SWITCHBOARD_FILE ]; then # Verifica se o fich. se encontra na dir
        echo -e "‚úÖ Ficheiro $SWITCHBOARD_FILE encontrado\n"
        FILE_LOCATED=true
    else
        while :
        do
            echo -e "‚ùå Ficheiro n√£o encontrado\n"
            echo "Insira o nome do ficheiro do switchboard!"
            echo "Ficheiros .zip na directoria $PWD"
            for file in ./*.zip # mostra todos os fich. disp. na dir.
            do
                echo " -> ${file##*/}"
            done
            echo -e "Insira a localiza√ß√£o do ficheiro do switchboard : "
            read ficheiro
            if [ -f $ficheiro  ]; then # verifica se o fich. existe
                clear
                echo -e "‚úÖ Ficheiro $ficheiro encontrado\n"
                SWITCHBOARD_FILE=$ficheiro
                FILE_LOCATED=true
                break
            fi  
            clear # limpa a consola
        done
    fi
}

# Fun√ß√£o para verificar se existe a estrutura de dir. a usar procura uma a uma
# caso n√£o existam cria as mesmas
CheckFolderStructure(){
    echo -e "\nüõ†  Incializando a verifica√ß√£o da estrutura de diretorias\n"
    $feeling
    for dir in ${DIRS[@]};
    do
        echo -n "üîé  Verificando a exist√™ncia da diretoria '$dir'"
        if [ -d $dir ]; then
            $feeling
            echo " ‚úÖ"
        else
            echo " ‚ùå"
            echo -n "    üìÇ diretoria inexistente criando diretoria '$dir'"
            $feeling
            mkdir $dir
            [[ $? -eq 0 ]] && echo " ‚úÖ" || echo " ‚ùé"
        fi
    done
    echo -e "Diretorias üÜó\n"
    DIR_STRUCT_OK=true
}

# Fun√ß√£o para carregar os scripts
Carregar_Script() {
    clear
    if [ -f $1 ]; then
        source $1 ${2:-""} ${3:-""}
    else
        echo -e "‚ùå ficheiro '$1 n√£o localizado\n"
        # todo realizar o download do ficheiro quando n√£o encontrado (git?)
        echo -en "\npressione qualquer tecla para voltar ao menu anterior!"
        read -n 1
    fi
}

while true; do
    clear >$(tty)
    echo "Bem vindo ao gerador de corpus para o Eug√©nio V3!"
    echo "-------------------------------------------------"
    if ! $DIR_STRUCT_OK; then
        CheckFolderStructure
    else
        echo "Diretorias üÜó"
    fi
    if ! $FILE_LOCATED; then
        SwitchBoard
    else
        echo -e "Ficheiro do switchboard üÜó \n"
    fi
    echo "Escolha a op√ß√£o pretendida"
    echo "--------------------------"
    echo " 0 - sair"
    echo " 1 - descompactar o switchboard"
    echo " 2 - caracterizar o corpus utilizado (corpus_info.txt)"
    echo " 3 - criar ficheiro de palavras (words.txt)"
    echo " 4 - criar ficheiro de pares palavras (words_pairs.txt)"
    echo " 5 - criar ficheiro de frases (sentences.txt)"
    echo " 6 - criar ficheiro de pares de frases (sentences_pairs.txt)"
    echo " "
    read -p " -> " option
    case $option in
        0) break ;;
        1) Carregar_Script "scripts/unzip_switchboard.sh" ;; 
        2) Carregar_Script "scripts/caracterizar_corpus.sh" ;;
        3) Carregar_Script $SCRIPT "words_table.awk" "words_dic/words.txt" ;;
        4) Carregar_Script $SCRIPT "word_pairs.awk" "words_dic/words_pairs.txt" ;;
        5) Carregar_Script $SCRIPT "unique_phrases.awk" "sentences_dic/sentences.txt" ;;
        6) Carregar_Script $SCRIPT "pair_phrases.awk" "sentences_dic/sentences_pairs.txt"
    esac
done

echo "FIM"
#+END_SRC

** Descompress√£o do corpus
Nesta espada iremos desompactar o corpus, para o efeito foi desenvolvido o script =unzip_switchboard.sh= que √© chamado pelo script =main.sh= op√ß√£o 1.

*** Ficheiro =unzip_switchboard.sh=

Neste script realizamos a extra√ß√£o dos ficheiros do =switchboard.zip=. O primeiro passo √© usar o comando /=unzip -uqj $SWITCHBOARD_FILE "switchboard/*.txt" -d corpus=/ que realiza apenas a extra√ß√£o dos ficheiros =txt= para a pasta =corpus=, dando-nos indica√ß√£o que a opera√ß√£o foi conclu√≠da com sucesso ou n√£o, recebendo mensagens que indicam o caso. Seguidamente o script cria junta todos os ficheiros de texto que existem no corpus num unico ficheiro com o nome =switchboard.txt=, para hevitar erros antes de ser criado, o scirpt verifica se j√° existe e remove caso exista antes de criar o novo.

#+NAME: unzip_switchboard.sh
#+BEGIN_SRC bash -n
#!/usr/bin/env bash
# unzip_switchboard.sh
# Autores: Jos√© Galinha, Luis Adriano
set -euo pipefail

echo -e "üöÄ Iniciando descompacta√ß√£o do ficheiro $SWITCHBOARD_FILE üóú"
$feeling
# comando unzip que apenas extrai os ficheiros txt do arquivo
# https://unix.stackexchange.com/questions/59276/how-to-extract-only-a-specific-folder-from-a-zipped-archive-to-a-given-directory
unzip -uqj $SWITCHBOARD_FILE "switchboard/*.txt" -d corpus 
$feeling

if [ $? -eq 0 ]; then # verifica se o comando unzip concluiu com sucesso
    echo "Ficheiros extraidos com sucesso ‚úÖ" 
    echo -n "Juntanto todos os ficheiros de texto num s√≥ üí§ ..."
    # verificar se o fich. output j√° existe, se existir apaga-o
    [[ -f output ]] && rm output 
    # percorre todos os ficheiros txt da pasta corpus e junta-os num fich. temp.
    for i in corpus/*.txt; do
        cat $i >> corpus/output
    done
    echo " ‚úÖ ficheiro criado com sucesso"
    echo -n "Movendo o ficheiro para a diretoria 'corpus_txt'"
    $feeling
    # verifica se o ficheiro j√° existe, se existir apaga-o
    [[ -f corpus_txt/switchboard.txt ]] && rm corpus_txt/switchboard.txt
    mv corpus/output corpus_txt/switchboard.txt
    $feeling
    # verifica se o comando mv teve sucesso, e mostra o output correspondente
    [[ $? -eq 0 ]] && echo " ‚úÖ" || echo " ‚ùé"
    echo "üìÑ Ficheiro criado em 'corpus_txt/switchboard.txt'"
else
    echo "A extaa√ß√£o dos ficheiros terminou com erros ‚ùé"
fi

echo -en "\nPressione qualquer tecla para voltar ao menu anterior!"
read -n 1
#+END_SRC

** Caracteriza√ß√£o do corpus

*** Ficheiro =caracterizar_corpus.sh=

Neste script, queremos caracterizar o ficheiro em rela√ß√£o ao n√∫mero de caracteres, linhas n√£o vazias, palavras, palavras diferentes, o quociente entre o total de palavras e palavras diferentes, frases, frases diferentes e o quociente entre o total de frases e frases diferentes. Para se realizar estas diferentes tarefas foram criados diferentes scripts: um para o n√∫mero de palavras, um para o n√∫mero de palavras diferentes, um para as frases e um para as frases diferentes, estes scripts ser√£o analisados mais abaixo. Estes scripts s√£o associados a v√°rias vari√°veis de modo a serem chamados quando o script principal for corrido. A primeira tarefa do script √© verificar se os scripts secund√°rios existem, se n√£o forem o programa n√£o corre. Ap√≥s isso, o script determina o n√∫mero de caracteres com o comando /=number_of_chars=$(wc -m $CORPUS_TXT | $cmd '{print $1}')=/, segue-se o n√∫mero de frases n√£o vazias com o comando /=number_of_non_empty_lines=$(sed '/^\s*$/d' $CORPUS_TXT | wc -l)=/. De seguida, o script principal corre os scripts de palavras diferentes e palavras totais e com os resultados desses scripts realiza o quociente entre eles com o comando /=quociente_palavras=$(awk "BEGIN{print ($unique_words * 100) / $words}")=/. Segue-se o mesmo processo com os scripts de frases diferentes e frases totais e a realiza√ß√£o do quociente entre eles com o comando /=quociente_frases=$(awk "BEGIN{print ($unique_phrases * 100_) / $phrases}")=/ . No final, o script cria um ficheiro output e coloca as respostas das diversas vari√°veis nesse ficheiro, apresentando tamb√©m o resultado ao utilizador.

#+NAME: caracterizar_corpus.sh
#+BEGIN_SRC bash -n
#!/usr/bin/env bash
###############################################################################
#                            caracterizar_corpus.sh                           #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro que chama dos v√°rios scripts para realizar a caract. do corpus #####
###############################################################################

set -euo pipefail

CUW="scripts/count_unique_words.awk"
CW="scripts/count_words.awk"
CP="scripts/count_phrases.awk"
CUP="scripts/count_unique_phrases.awk"
control=true
OUTPUT_FILE="corpus_info/corpus_info.txt"


# verifica a exist√™ncia do prog. nawk, em alternativa usa o awk
[[ $(command -v nawk) ]] && cmd="nawk" || cmd="awk"
if [ ! -f $CUW ]; then
    echo "‚ùé O ficheiro '$CUW' n√£o foi encontrado, o programa n√£o pode continuar"  
    control=false
fi

if [ ! -f $CW ]; then
    echo "‚ùé O ficheiro '$CW' n√£o foi encontrado, o programa n√£o pode continuar"  
    control=false
fi

if [ ! -f $CP ]; then
    echo "‚ùé O ficheiro '$CP' n√£o foi encontrado, o programa n√£o pode continuar"  
    control=false
fi
if [ ! -f $CUP ]; then
    echo "‚ùé O ficheiro '$CUP' n√£o foi encontrado, o programa n√£o pode continuar"  
    control=false
fi
if $control; then
    echo -e "Caracterizando o corpus... üìÉ\n"
    number_of_chars=$(wc -m $CORPUS_TXT | $cmd '{print $1}')
    number_of_non_empty_lines=$(sed '/^\s*$/d' $CORPUS_TXT | wc -l)
    unique_words=$(cat $CORPUS_TXT | $cmd -f $CUW )
    words=$(cat $CORPUS_TXT | $cmd -f $CW)
    quociente_palavras=$(awk "BEGIN{print ($unique_words * 100) / $words}")
    phrases=$(cat $CORPUS_TXT | $cmd -f $CP)
    unique_phrases=$(cat $CORPUS_TXT | $cmd -f $CUP)
    quociente_frases=$(awk "BEGIN{print ($unique_phrases * 100) / $phrases}")
    
    echo "N√∫mero de caracteres: $number_of_chars" > $OUTPUT_FILE
    echo "N√∫mero de linhas n√£o vazias: $number_of_non_empty_lines" >> $OUTPUT_FILE
    echo "N√∫mero de palavras: $words" >> $OUTPUT_FILE
    echo "Numero de palavras diferentes: $unique_words" >> $OUTPUT_FILE
    echo "Apenas $quociente_palavras% das palavras s√£o unicas" >> $OUTPUT_FILE
    echo "N√∫mero de frases: $phrases" >> $OUTPUT_FILE
    echo "N√∫mero de frases √∫nicas $unique_phrases" >> $OUTPUT_FILE
    echo "$quociente_frases% das frases s√£o √∫nicas" >> $OUTPUT_FILE
    # https://www.shell-tips.com/bash/math-arithmetic-calculation/
    # printf %.2f%% "$((10**3 * 100 * $unique_words / $words))e-3"
    cat $OUTPUT_FILE

fi

echo -en "\nPressione qualquer tecla para voltar ao menu anterior!"
read -n 1

#+END_SRC

** Cria√ß√£o dos v√°rios ficheiros

Para cria√ß√£o dos v√°rios ficheiros foi desenvolvido o script =criar_ficheiros.sh= que por sua vez recebe os ficheiros de destino a gerar e o script awk respons√°vel pelo tratamento da informa√ß√£o

*** Ficheiro =criar_ficheiros.sh=

Neste script, procuramos criar um ficheiro de palavras, contar as palavras do ficheiro e quantas vezes cada palavra ocorre. O primeiro passo √© a colocar em vari√°vel o script de palavras para a cria√ß√£o do ficheiro de palavras e um limite. O script deve dar indica√ß√£o que esta opera√ß√£o foi um sucesso ou n√£o. De seguida, ocorre a cria√ß√£o do ficheiro de palavras com o comando =cat $CORPUS_TXT | $cmd -f $WT | sort -k 1 | $cmd -v limit=$LIMIT -f $LM > $OUTPUT_FILE=. Por fim, o ficheiro indica se a opera√ß√£o anterior foi completa com sucesso.


#+NAME: criar_ficheiros.sh
#+BEGIN_SRC bash -n
#!/usr/bin/env bash
# Autores: Jos√© Galinha, Luis Adriano
#
# 
set -euo pipefail

WT="scripts/"$1
OUTPUT_FILE=$2
LM="scripts/limit.awk"

# verifica a exist√™ncia do prog. nawk, em alternativa usa o awk
[[ $(command -v nawk) ]] && cmd="nawk" || cmd="awk"
# Verifica se o script awk existe
if [ ! -f $WT ]; then
    echo "‚ùé O ficheiro '$WT' n√£o foi encontrado, o programa n√£o pode continuar" 
else
    echo -e "Criando o ficheiro ... üìù\n"
    # Cria√ß√£o do ficheiro de cria√ß√£o de palavras
    cat $CORPUS_TXT | $cmd -f $WT | sort -k 1 | $cmd -v limit=$LIMIT -f $LM > $OUTPUT_FILE
    # Verifica se o comando anterior foi concluido com sucesso
    [[ $? -eq 0 ]] && echo "Ficheiro '$OUTPUT_FILE' criado com sucesso ‚úÖ" ||
            echo "Erro na cria√ß√£o do ficheiro ‚ùå"
fi

echo -en "\nPressione qualquer tecla para voltar ao menu anterior!"
read -n 1

#+END_SRC

*** Ficheiro =count_words.awk=

Neste script, procuramos o n√∫mero de palavras no SwitchBoard. Para calcular isso, primeiro definimos que uma palavras como um conjunto de caracteres  que n√£o possua  dois travess√µes seguidos com as condi√ß√µes =( $0 ~ /[-A-Za-z]+/ ) e ( $0 !~ /\-\-/)=. Quando se deteta uma palavras ela √© guardada na vari√°vel tabelaOcorrencias. No final o script indica o total de palavras encontradas.

#+NAME: count_words.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                               count_words.awk                               #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Fichiro para contar a palavras num ficheiro de texto ########################
###############################################################################


BEGIN{
    RS="[ \n\t,.¬´¬ª:)(;/?\"!]+";   
    i=0;
}

# Para ser considerada palavra tem de ser constituida por os caracteres indicados
# && nao conter dois travessoes seguidos 
( $0 ~ /[A-Za-z]+/ ) && ( $0 !~ /\-\-/) {
    if (length($0) > 1)
        i++;
}

END{
    print i
}

#+END_SRC

*** Ficheiro =count_unique_words.awk=

Neste script, procuramos o n√∫mero de palavras diferentes no SwitchBoard. Para calcular isso, primeiro definimos que uma palavras como um conjunto de caracteres  que n√£o possua  dois travess√µes seguidos com as condi√ß√µes =( $0 ~ /[-A-Za-z]+/ ) e ( $0 !~ /\-\-/)=. Quando se deteta uma palavras ela √© guardada na vari√°vel tabelaOcorrencias e se for encontrada outra vez √© incrementado um contador para indicar que tal ocorreu. No final o script indica o n√∫mero de palavras √∫nicas encontradas.

#+NAME: count_unique_words.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                            count_unique_words.awk                           #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro para contar as palavras unicas num ficheiro de texto ###############
###############################################################################

BEGIN{
    RS="[ \n\t,.¬´¬ª:)(;/?\"!]+";   
}

# Para ser considerada palavra tem de ser constituida por os caracteres indicados
# && nao conter dois travessoes seguidos 
( $0 ~ /[-A-Za-z]+/ ) && ( $0 !~ /\-\-/) {
    palavra = tolower($0)
    if (length(palavra) > 1) {
        if( palavra in tabelaOcorrencias )
            tabelaOcorrencias[ palavra ] ++;
        else
            tabelaOcorrencias[ palavra ] = 1;
    }
}

END{
    print length(tabelaOcorrencias)
}

#+END_SRC

*** Ficheiro =count_phrases.awk=

Neste script, procuramos o n√∫mero de frases diferentes do SwitchBoard. O primeiro passo √© criar os delimitadores de frases denominados =RS= para determinar uma frase. De seguida, eliminamos os espa√ßos em branco para nos certificarmos que n√£o contamos linhas vazias usando o comando =gsub(/^[[:blank:]]+/,"",$0)=. Ap√≥s isso, guardamos o n√∫mero de frases encontradas na vari√°vel =z=. No final, o script indica o n√∫mero de frases guardado em =z=.

#+NAME: count_phrases.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                              count_phrases.awk                              #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro para contar as frases de um ficheiro de texto ######################
###############################################################################

BEGIN{
    # Delimitadores de frases
    RS="[\n\t!?,:;..{3}]+";   
    z=0;
}

{
    # Vamos eliminar todos os espa√ßos brancos no inicio das linhas com o gsub
    gsub(/^[[:blank:]]+/,"",$0)
    # Com este if estamos a garantir que n√£o contamos linhas vazias
    if (NF > 0) {
        z++;
    }
}

END{
    print z
}

#+END_SRC


*** Ficheiro =count_unique_phrases.awk=

Neste script, procuramos o n√∫mero de frases diferentes do SwitchBoard. O primeiro passo √© criar os delimitadores de frases denominados =RS= para determinar uma frase. De seguida, eliminamos os espa√ßos em branco para nos certificarmos que n√£o contamos linhas vazias usando o comando =gsub(/^[[:blank:]]+/,"",$0)=. Ap√≥s este passo, contamos  cada frase que encontramos e guardamos a frase numa tabela. Se uma frase for repetida, aumentamos um contador para indicar isso. No final, o script imprime a tabela de frases encontradas.

#+NAME: count_unique_phrases.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                           count_unique_phrases.awk                          #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro para contar as frases unicas num ficheiro de texto ################# 
###############################################################################

BEGIN{
    # Delimitadores de frases
    RS="[\n\t!?,:;..{3}]+";   
}

{
    # Vamos eliminar todos os espa√ßos brancos no inicio das linhas com o gsub
    gsub(/^[[:blank:]]+/,"",$0)
    #  Com este IF estamos a garantir que n√£o contamos linhas vazias
    if (NF > 0){
        if ($0 in tabela)
            tabela[$0] ++;
        else
            tabela[$0] = 1;
    }
}

END{
    print length(tabela)
}

#+END_SRC

*** Ficheiro =word_pairs.awk=

Neste script, desejamos agrupar as palavras do /SwitchBoard/ aos pares. Primeiro criamos um ciclo que agrupa as palavras quando a encontra duas para seguidas numa frase. No interior desse ciclo, criamos uma condi√ß√£o para determinar se numa frase existem palavras, que tem de ter mais do que uma letra. Se este for o caso adicionasse um valor ao contador =tabelaPares[par]=, se n√£o o  valor desse contador √© 1. No final, o script indica-nos o n√∫mero de pares encontrados.

#+NAME: word_pairs.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                                word_pairs.awk                               #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro para contar o numero de ocorr√™ncia de pares de palavras num fich. ##
###############################################################################

BEGIN{
}
# Exclui todas as palavras que est√£o sozinhas
(NF > 1){
    # Ciclo inicia em dois pois come√ßamos por escolher a (x-1) palavras
    for (x = 2; x <= NF; x++) {
        # Verifica se o $x tem mais de uma letra para ser considerado palavra
        if (length($x) > 1) {
            par = tolower($(x-1) " " $x)
            if (par in tabelaPares){
                tabelaPares[par]++;
            } else {
                tabelaPares[par] = 1;
            }
        } else {
            # Aumenta o valor do x para n√£o fazer par com letras isoladas
            x++
        }
    }
}
END {
    # Imprime para o ecr√¢ a tabela de pares
    for (par in tabelaPares){
        print par, tabelaPares[par]
    }
}

#+END_SRC

*** Ficheiro =pair_phrases.awk=

Neste script para criar pares de frases, primeiro indica-se quais as condi√ß√µes para ser considerada uma frase, que se faz com delimitadores de frases indicados em =RS ="[\n\t!?,:;..{3}]+"=. Ap√≥s isso, removemos os espa√ßos brancos com o comando =gsub(/^[[:blank:]]+/,"",$0)= e depois substitu√≠mos com o caracter ‚Äú|‚Äù com o comando =gsub(/[[:blank:]]+/,"|",$0)=. Depois realizamos o par quando a condi√ß√£o que o counter = 0 √© confirmada e verificamos se o par j√° existe na tabela, que se n√£o existir adiciona-se √† tabela. No final, o programa imprime a tabela com os pares de frase.

#+NAME: pair_phrases.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                               pair_phrases.awk                              #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro para contar o numero de pares de frases num ficheiro de texto ######
###############################################################################

BEGIN{
    # Delimitadores de frases
    RS="[\n\t!?,:;..{3}]+";   
    frase = ""
    counter = 0
}

{
    # Vamos eliminar todos os espa√ßos brancos no inicio das linhas com o gsub
    gsub(/^[[:blank:]]+/,"",$0)
    if (NF > 0){
        # Comando gsub para substituir todos os espa√ßos por '|''
        gsub(/[[:blank:]]+/,"|",$0)
        if (counter == 0){
            par = $0
            counter = 1
        } else {
            # Constru√ß√£o do par
            par = tolower(par " " $0)
            # Verifica√ß√£o se o par j√° existe na tabela, se n√£o existir inicia a 1
            if (par in tabela) {
                tabela[par] ++
            } else {
                tabela[par] = 1
            }
            # Igual o par a ultima frase para a combinar com a pr√≥xima
            par = $0
        }
    }
}

END{
    # Impress√£o dos resultados obtidos
    for (frase in tabela)
        print frase, tabela[frase]
}

#+END_SRC

*** Ficheiro =words_table.awk=

O script =word_table.awk=, semelhante ao script =count_words.awk= com a diferen√ßa que √© criada uma tabela de ocorr√™ncias para a cria√ß√£o do ficheiro a usar no dicion√°rio.

#+NAME: words_table.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                               words_table.awk                               #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Ficheiro para contar o numero de ocorr√™ncias de uma palavra num ficheiro ####
###############################################################################

BEGIN{
    RS="[ \n\t,.¬´¬ª:)(;/?\"\"!]+";   
}

# Para ser considerada palavra tem de ser constituida por os caracteres indicados
# && nao conter dois travessoes seguidos 
( $0 ~ /[A-Za-z]+/ ) && ( $0 !~ /\-\-/) {
    palavra = tolower($0)
    if (length(palavra) > 1 ) {
        if( palavra in tabelaOcorrencias )
            tabelaOcorrencias[ palavra ] ++;
        else
            tabelaOcorrencias[ palavra ] = 1;
    }
}

END{
    for (palavra in tabelaOcorrencias)
        print palavra, tabelaOcorrencias[palavra];
}
#+END_SRC 

*** Ficheiro =limit.awk=

O script =limit.awk= √© um script auxiliar criado para limitar o n√∫mero de linhas a exportar na cria√ß√£o dos ficheiros de dicion√°rios, sendo-lhe passada a vari√°vel =limit= definida no script =main.sh=

#+NAME: limit.awk
#+BEGIN_SRC awk -n
#!/usr/bin/awk
###############################################################################
#                               pair_phrases.awk                              #
# Autores: Jos√© Galinha, Luis Adriano #########################################
# Script para limitar o numero de linhas dos ficheiros txt                    # 
###############################################################################

BEGIN{
    i = 0
}

(i < limit) {
    print $0
    i++
}

END{
}
#+END_SRC

*** Ficheiro =windows_install.bat=

O script =windows_install.bat= foi desenvolvido para quando acompanhado pelos ficheiros criados com o script =main.sh= instalar os dicion√°rios no sistema operativo /Windows/. O memso deteta a pasta de instala√ß√£o do =Eug√©nio= e copia os ficheiros fazendo a convers√£o para os nomes e tipos de ficheiro usados pelo =Eug√©nio=

#+NAME: windows_install.bat
#+BEGIN_SRC batch -n
::===============================================================
:: Script de instala√ß√£o dos ficheiros do Eug√©nio V3 no windows
::
::===============================================================
@ECHO OFF
:: Windows version check
IF NOT "%OS%"=="Windows_NT" GOTO NotWindows
:: ### START UAC SCRIPT ###
:: https://stackoverflow.com/questions/14639743/batch-script-to-run-as-administrator
if "%2"=="firstrun" exit
cmd /c "%0" null firstrun

if "%1"=="skipuac" goto skipuacstart

:checkPrivileges
NET FILE 1>NUL 2>NUL
if '%errorlevel%' == '0' ( goto gotPrivileges ) else ( goto getPrivileges )

:getPrivileges
if '%1'=='ELEV' (shift & goto gotPrivileges)

setlocal DisableDelayedExpansion
set "batchPath=%~0"
setlocal EnableDelayedExpansion
ECHO Set UAC = CreateObject^("Shell.Application"^) > "%temp%\OEgetPrivileges.vbs"
ECHO UAC.ShellExecute "!batchPath!", "ELEV", "", "runas", 1 >> "%temp%\OEgetPrivileges.vbs"
"%temp%\OEgetPrivileges.vbs"
exit /B

:gotPrivileges

setlocal & pushd .

cd /d %~dp0
cmd /c "%0" skipuac firstrun
cd /d %~dp0

:skipuacstart

if "%2"=="firstrun" exit

:: ### END UAC SCRIPT ###

:: ### START OF YOUR OWN BATCH SCRIPT BELOW THIS LINE ###
:: Comando para permitir os caracteres unicode
chcp 1252
SET DIR=Eug√©nio
SET CONTROL=false

:CheckDirectory
IF EXIST "%PROGRAMFILES%\%DIR%" (
   SET DEST=%PROGRAMFILES%\%DIR%
   SET CONTROL=true
   GOTO Copy
) ELSE (
  GOTO NotFound
)
IF EXIST "%PROGRAMFILES(x86)%\%DIR%" (
   SET DEST=%PROGRAMFILES(x86)%\%DIR%
   SET CONTROL=true
   GOTO Copy
) ELSE (
  GOTO NotFound
)

IF %CONTROL% equ false (
   GOTO NotFound
)

:NotFound
ECHO "Pasta do Eug√©nio n√£o encontrada! Instale o Eug√©nio e volte a tentar."
GOTO Exit

:Copy
ECHO Diretoria '%DEST%' detectada iniciando copia de ficheiros
COPY /y ".\words_dic\words.txt" "%DEST%\geral.pal"
COPY /y ".\words_dic\words_pairs.txt" "%DEST%\geral.par"
COPY /y ".\sentences_dic\sentences.txt" "%DEST%\geral.frs"
COPY /y ".\sentences_dic\sentences_pairs.txt" "%DEST%\geral.paf"
ECHO " Ficheiros copiados!"
pause
GOTO Exit

:NotWindows
ECHO Este ficheiro √© para ser usado num SO Windows

:Exit
exit /b 0
#+END_SRC

* 
** Conclus√£o

Com este trabalho, treinamos a utiliza√ß√£o de comandos de Linux na linha de comandos para a realiza√ß√£o de scripts de modo a realizar tarefas mais complexas em rela√ß√£o ao sistema do Eug√©nio. Alem disso, treinamos tamb√©m a nossa habilidade e compreens√£o com os diversos comandos do Linux como prepara√ß√£o a realizar tarefas de maior dificuldade no futuro. Podemos concluir que o objetivo da realiza√ß√£o do trabalho, os scripts, foram conclu√≠dos com sucesso.
